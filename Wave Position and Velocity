from matplotlib import animation
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

# There are N masses and n = N - 1 springs.
N = np.linspace(0, 60, 61)
m_index_N = len(N)-1  # Goes from index 0 to 2 so the Nth index is actually len
sp_index_n = len(N)-2  # Goes from index 0 to 1 so the nth index is actually len(N)-2
num_masses = len(N)
num_springs = len(N) - 1

# parameters
# for simplicity, all masses are 1 kg, all sp constants k are random numbers based on gaussian distribution, all equilibrium lengths 1 m.
m = np.ones(num_masses)
k = np.random.normal(1, 0.2, num_springs)
L = np.ones(num_springs)

# initial conditions:
# equilibrium initial lengths, with 1 m/s velocity in spring 0.
x0 = np.linspace(0, num_masses, num_masses)
v0 = np.zeros(num_masses)
v0[0] = 2 #m/s
# time interval, in seconds
t = np.linspace(0, 300, 100000)


N_x_arrays = np.zeros((num_masses, len(t)))
N_v_arrays = np.zeros((num_masses, len(t)))

print(np.shape(N_x_arrays))




# First of the array is initial condition
for i in range(num_masses):
    N_x_arrays[i][0] = x0[i]
    N_v_arrays[i][0] = v0[i]

# The "starting" current positions and velocities arrays
x_current = x0
v_current = v0

# ode solving for loop
# Update x or y current using derivative and time step
# Then update position arrays with current x


for i in range(len(t) - 1):
    ts = t[i + 1] - t[i]
    v0d = (k[0] * (x_current[1] - x_current[0] - L[0])) / m[0]
    vNd = -(k[sp_index_n] * (x_current[m_index_N] - x_current[m_index_N - 1] - L[sp_index_n])) / m[m_index_N]

    x0d = v_current[0]
    xNd = v_current[m_index_N]

    x_current[0] = x_current[0] + x0d * ts
    x_current[m_index_N] = x_current[m_index_N] + xNd * ts
    v_current[0] = v_current[0] + v0d * ts
    v_current[m_index_N] = v_current[m_index_N] + vNd * ts

    N_x_arrays[0][i + 1] = x_current[0] # this sets the initial condition for the NEXT iteration, hence the i+1
    N_x_arrays[m_index_N][i+ 1] = x_current[m_index_N]
    N_v_arrays[0, i+1] = v_current[0]
    N_v_arrays[m_index_N, i+1] = v_current[m_index_N]

    # Middle masses for loop
    for m_index in range(1, m_index_N):
        v_interior_d = (-k[m_index-1]*(x_current[m_index] - x_current[m_index - 1] - L[m_index-1])
                        + k[m_index]*(x_current[m_index+1] - x_current[m_index] - L[m_index])) / m[m_index]
        x_interior_d = v_current[m_index]

        x_current[m_index] = x_current[m_index] + x_interior_d * ts
        v_current[m_index] = v_current[m_index] + v_interior_d * ts

        N_x_arrays[m_index][i + 1] = x_current[m_index] # this sets the initial condition for the NEXT iteration, hence the i+1
        N_v_arrays[m_index, i+1] = v_current[m_index]



# Now we have an array of springs that have positions stored per time step
# x coordinate is the equilibrium x position of the springs
# y coordinate is its deviation from the equilibrium position
# Animate and store images into file


# Potential of Each Mass is made up of kinetic energy and spring potential energy.
# Kinetic Energy
N_KE_arrays = np.zeros((num_masses,len(t)))

# Calculate kinetic energy using calculated velocity array
for i in range(num_masses):
    for time_step in range(len(t)-1):
        N_KE_arrays[i ,time_step] = 0.5 * m[i] * N_v_arrays[i,time_step]**2
#plot


# Spring Potential Energy Array
N_U_arrays = np.zeros((num_masses,len(t)))

for ts in range(len(t)-1):
    N_U_arrays[m_index_N, ts] = 0.25*k[sp_index_n]*(N_x_arrays[m_index_N, ts]-N_x_arrays[m_index_N-1, ts]-L[sp_index_n])**2
    N_U_arrays[0, ts] = 0.25*k[0]*(N_x_arrays[1, ts]-N_x_arrays[0, ts]-L[0])**2

    for i in range(1, m_index_N):
        N_U_arrays[i, ts] = (0.25)*k[i]*(N_x_arrays[i+1, ts]-N_x_arrays[i, ts]-L[i])**2 + \
                                   (0.25)*k[i-1]*(N_x_arrays[i, ts]-N_x_arrays[i-1, ts]-L[i-1])**2


print(N_KE_arrays)
# Find the index of the mass with the highest kinetic energy at each time step
Max_KE_position_array = np.zeros(len(t))
Current_KE_index = 0
for ts in range(len(t)):
    Max_KE_index = np.argmax(N_KE_arrays[:,ts]) # returns indices
    print(Max_KE_index)
    Max_KE_position_array[ts] = (N_x_arrays[Max_KE_index, ts])
    Current_KE_index = Max_KE_index

    if Max_KE_position_array[ts] >= N_x_arrays[num_masses-1, ts]:
        Max_KE_position_array = Max_KE_position_array[0:ts]
        break
print(Max_KE_position_array)



v_wave_time_step = 2000+1
v_wave = np.zeros(len(Max_KE_position_array) - v_wave_time_step) # accounting for boundary effects
for ts in range(len(Max_KE_position_array)-v_wave_time_step):
    time_step = t[ts+(v_wave_time_step -1)] - t[ts]
    pos_step = Max_KE_position_array[ts+(v_wave_time_step -1)]-Max_KE_position_array[ts]
    v_wave[ts] = pos_step/time_step


fig = plt.figure()
fig.add_subplot(121)
plt.plot(range(len(Max_KE_position_array)), Max_KE_position_array)
plt.title('Wave Position')
plt.xlabel("Time (s)")
plt.ylabel("Position (m)")

plt.subplots_adjust(wspace = 0.5) # separates the subplots

fig.add_subplot(122)
plt.plot(range(len(v_wave)), v_wave)

plt.title('Wave Velocity')
plt.xlabel("Time (s)")
plt.ylabel("Velocity (m/s)")


plt.savefig('/Users/RyanWong/Desktop/PythonPlots/vwave')
