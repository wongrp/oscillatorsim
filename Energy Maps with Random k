from matplotlib import animation
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

# There are N masses and n = N - 1 springs.
N = np.linspace(0, 30, 31)
m_index_N = len(N)-1  # Goes from index 0 to 2 so the Nth index is actually len
sp_index_n = len(N)-2  # Goes from index 0 to 1 so the nth index is actually len(N)-2
num_masses = len(N)
num_springs = len(N) - 1

# parameters
# for simplicity, all masses are 1 kg, all sp constants are 1, all equilibrium lengths 1 m.
m = np.ones(num_masses)
k = np.random.normal(1, 0.2, num_springs)
L = np.ones(num_springs)

# initial conditions:
# equilibrium initial lengths, with 1 m/s velocity in spring 0.
x0 = np.linspace(0, num_masses, num_masses)
v0 = np.zeros(num_masses)
v0[0] = 2
# time interval, in seconds
t = np.linspace(0, 70, 70000)


N_x_arrays = np.zeros((num_masses, len(t)))
N_v_arrays = np.zeros((num_masses, len(t)))

print(np.shape(N_x_arrays))




# First of the array is initial condition
for i in range(num_masses):
    N_x_arrays[i][0] = x0[i]
    N_v_arrays[i][0] = v0[i]

# The "starting" current positions and velocities arrays
x_current = x0
v_current = v0

# ode solving for loop
# Update x or y current using derivative and time step
# Then update position arrays with current x


for i in range(len(t) - 1):
    ts = t[i + 1] - t[i]
    v0d = (k[0] * (x_current[1] - x_current[0] - L[0])) / m[0]
    vNd = -(k[sp_index_n] * (x_current[m_index_N] - x_current[m_index_N - 1] - L[sp_index_n])) / m[m_index_N]

    x0d = v_current[0]
    xNd = v_current[m_index_N]

    x_current[0] = x_current[0] + x0d * ts
    x_current[m_index_N] = x_current[m_index_N] + xNd * ts
    v_current[0] = v_current[0] + v0d * ts
    v_current[m_index_N] = v_current[m_index_N] + vNd * ts

    N_x_arrays[0][i + 1] = x_current[0] # this sets the initial condition for the NEXT iteration, hence the i+1
    N_x_arrays[m_index_N][i + 1] = x_current[m_index_N]
    N_v_arrays[0, i+1] = v_current[0]
    N_v_arrays[m_index_N, i+1] = v_current[m_index_N]

    # Middle masses for loop
    for m_index in range(1, m_index_N):
        v_interior_d = (-k[m_index-1]*(x_current[m_index] - x_current[m_index - 1] - L[m_index-1])
                        + k[m_index]*(x_current[m_index+1] - x_current[m_index] - L[m_index])) / m[m_index]
        x_interior_d = v_current[m_index]

        x_current[m_index] = x_current[m_index] + x_interior_d * ts
        v_current[m_index] = v_current[m_index] + v_interior_d * ts

        N_x_arrays[m_index][i + 1] = x_current[m_index] # this sets the initial condition for the NEXT iteration, hence the i+1
        N_v_arrays[m_index, i+1] = v_current[m_index]



# Now we have an array of springs that have positions stored per time step
# x coordinate is the equilibrium x position of the springs
# y coordinate is its deviation from the equilibrium position
# Animate and store images into file


# Potential of Each Mass is made up of kinetic energy and spring potential energy.
# Kinetic Energy
N_KE_arrays = np.zeros((num_masses,len(t)))

# Calculate kinetic energy using calculated velocity array
for i in range(num_masses):
    for time_step in range(len(t)-1):
        N_KE_arrays[i ,time_step] = 0.5 * m[i] * N_v_arrays[i,time_step]**2
#plot


# Spring Potential Energy Array
N_U_arrays = np.zeros((num_masses,len(t)))

for ts in range(len(t)-1):
    N_U_arrays[m_index_N, ts] = 0.25*k[sp_index_n]*(N_x_arrays[m_index_N, ts]-N_x_arrays[m_index_N-1, ts]-L[sp_index_n])**2
    N_U_arrays[0, ts] = 0.25*k[0]*(N_x_arrays[1, ts]-N_x_arrays[0, ts]-L[0])**2

    for i in range(1, m_index_N):
        N_U_arrays[i, ts] = (0.25)*k[i]*(N_x_arrays[i+1, ts]-N_x_arrays[i, ts]-L[i])**2 + \
                                   (0.25)*k[i-1]*(N_x_arrays[i, ts]-N_x_arrays[i-1, ts]-L[i-1])**2




print(np.shape(t))
print(np.shape(N_KE_arrays))
print(np.shape(N_x_arrays[0]))


# Next: Finding wave velocity comes next (velocity of center of mass)


# color maps for potential and kinetic energy

fig = plt.figure()
ax1 = fig.add_subplot(211)
KE_plot = ax1.matshow(N_KE_arrays, aspect = 'auto', extent = [0,t[-1], 0, num_masses])
plt.gca().xaxis.tick_bottom() # switches x-axis from top to bottom
plt.title("Kinetic Energy(J) of 1D Mass Spring System")
plt.ylabel("Mass Index")
plt.xlabel("Time (s)")
plt.colorbar(KE_plot)

plt.subplots_adjust(hspace = 1) # separates the subplots

ax2 = fig.add_subplot(212)
U_plot = ax2.matshow(N_U_arrays, aspect = 'auto', extent = [0,t[-1], 0, num_masses])
plt.gca().xaxis.tick_bottom() # switches x-axis from top to bottom
plt.colorbar(U_plot)
plt.title("Potential Energy (J) of 1D Mass Spring System")
plt.xlabel("Time (s)")
plt.ylabel("Mass Index")


plt.savefig('/Users/RyanWong/Desktop/PythonPlots/EnergyMap')

plt.figure()
# 3D Kinetic Energy plot
for i in range(num_masses):
    plt.scatter(t, N_x_arrays[i], c = N_KE_arrays[i])
plt.colorbar
plt.savefig('/Users/RyanWong/Desktop/PythonPlots/KineticEnergyScatter')

# 3D Potential Energy plot
for i in range(num_masses):
    plt.scatter(t, N_x_arrays[i], c = N_U_arrays[i])
plt.colorbar
plt.savefig('/Users/RyanWong/Desktop/PythonPlots/PotentialEnergyScatter')

